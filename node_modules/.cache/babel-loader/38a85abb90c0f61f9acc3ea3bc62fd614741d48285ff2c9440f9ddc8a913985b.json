{"ast":null,"code":"import _objectSpread from\"C:/Users/Lucas Araujo/Desktop/supabase/DeckMaster/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\r\n * üîç QUERY MANAGER - Camada de Consultas Offline-First\r\n * =====================================================\r\n * Gerencia consultas priorizando IndexedDB (cache local)\r\n * \r\n * ESTRAT√âGIA:\r\n * 1. Busca SEMPRE do IndexedDB primeiro (instant√¢neo)\r\n * 2. Retorna dados locais imediatamente\r\n * 3. Em background, sincroniza com Firebase\r\n * 4. Notifica componentes quando dados atualizarem\r\n * \r\n * BENEF√çCIOS:\r\n * - Performance instant√¢nea\r\n * - Funciona 100% offline\r\n * - Sincroniza√ß√£o transparente\r\n */import unifiedStorage from'./unifiedStorage';import syncManager from'./syncManager';import{db}from'../firebase';import{collection,query,where,getDocs,doc,getDoc}from'../firebase';class QueryManager{constructor(){this.cache=new Map();// Cache em mem√≥ria para queries recentes\nthis.listeners=new Map();// Listeners para atualiza√ß√µes\n}/**\r\n   * üë§ Busca perfil do usu√°rio\r\n   */async getUserProfile(userId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{forceRefresh=false}=options;try{// 1. Busca do cache local (instant√¢neo)\nconst cachedProfile=await unifiedStorage.getUserProfile(userId);if(cachedProfile&&!forceRefresh){console.log('‚ö° Perfil carregado do cache');// Em background, atualiza do Firebase\nthis.refreshUserProfileInBackground(userId);return cachedProfile;}// 2. Se n√£o tem cache ou forceRefresh, busca do Firebase\nif(navigator.onLine){console.log('üåê Buscando perfil do Firebase...');const profile=await this.fetchUserProfileFromFirebase(userId);if(profile){// Salva no cache\nawait unifiedStorage.saveUserProfile(profile);return profile;}}// 3. Fallback para cache mesmo que antigo\nreturn cachedProfile;}catch(error){console.error('‚ùå Erro ao buscar perfil:',error);// Tenta retornar cache em caso de erro\nreturn await unifiedStorage.getUserProfile(userId);}}/**\r\n   * üîÑ Atualiza perfil em background\r\n   */async refreshUserProfileInBackground(userId){if(!navigator.onLine)return;try{const profile=await this.fetchUserProfileFromFirebase(userId);if(profile){await unifiedStorage.saveUserProfile(profile);this.notifyListeners(\"user_\".concat(userId),profile);}}catch(error){console.error('‚ùå Erro ao atualizar perfil em background:',error);}}/**\r\n   * üåê Busca perfil do Firebase\r\n   */async fetchUserProfileFromFirebase(userId){const docRef=doc(db,'users',userId);const docSnap=await getDoc(docRef);if(docSnap.exists()){return _objectSpread({userId},docSnap.data());}return null;}/**\r\n   * üÉè Busca todos os decks do usu√°rio\r\n   */async getUserDecks(userId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{forceRefresh=false}=options;try{// 1. Busca do cache local (instant√¢neo)\nconst cachedDecks=await unifiedStorage.getUserDecks(userId);if(cachedDecks.length>0&&!forceRefresh){console.log(\"\\u26A1 \".concat(cachedDecks.length,\" decks carregados do cache\"));// Em background, sincroniza com Firebase\nthis.refreshDecksInBackground(userId);return cachedDecks;}// 2. Se n√£o tem cache ou forceRefresh, busca do Firebase\nif(navigator.onLine){console.log('üåê Buscando decks do Firebase...');await syncManager.pullFromFirebase(userId);// Retorna dados atualizados do cache\nreturn await unifiedStorage.getUserDecks(userId);}// 3. Fallback para cache vazio\nreturn cachedDecks;}catch(error){console.error('‚ùå Erro ao buscar decks:',error);return await unifiedStorage.getUserDecks(userId);}}/**\r\n   * üîÑ Atualiza decks em background\r\n   */async refreshDecksInBackground(userId){if(!navigator.onLine)return;try{await syncManager.pullFromFirebase(userId);const updatedDecks=await unifiedStorage.getUserDecks(userId);this.notifyListeners(\"decks_\".concat(userId),updatedDecks);}catch(error){console.error('‚ùå Erro ao atualizar decks em background:',error);}}/**\r\n   * üé¥ Busca deck espec√≠fico\r\n   */async getDeck(deckId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{forceRefresh=false}=options;try{// 1. Busca do cache local\nconst cachedDeck=await unifiedStorage.getDeck(deckId);if(cachedDeck&&!forceRefresh){console.log('‚ö° Deck carregado do cache:',deckId);// Background refresh\nthis.refreshDeckInBackground(deckId);return cachedDeck;}// 2. Busca do Firebase se online\nif(navigator.onLine){console.log('üåê Buscando deck do Firebase:',deckId);const deck=await this.fetchDeckFromFirebase(deckId);if(deck){await unifiedStorage.saveDeck(deck,{synced:true});return deck;}}return cachedDeck;}catch(error){console.error('‚ùå Erro ao buscar deck:',error);return await unifiedStorage.getDeck(deckId);}}/**\r\n   * üîÑ Atualiza deck em background\r\n   */async refreshDeckInBackground(deckId){if(!navigator.onLine)return;try{const deck=await this.fetchDeckFromFirebase(deckId);if(deck){await unifiedStorage.saveDeck(deck,{synced:true});this.notifyListeners(\"deck_\".concat(deckId),deck);}}catch(error){console.error('‚ùå Erro ao atualizar deck em background:',error);}}/**\r\n   * üåê Busca deck do Firebase\r\n   */async fetchDeckFromFirebase(deckId){const docRef=doc(db,'decks',deckId);const docSnap=await getDoc(docRef);if(docSnap.exists()){return _objectSpread({id:deckId},docSnap.data());}return null;}/**\r\n   * üé¥ Busca cartas de um deck\r\n   */async getDeckCards(deckId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{forceRefresh=false}=options;try{// 1. Busca do cache local\nconst cachedCards=await unifiedStorage.getDeckCards(deckId);if(cachedCards.length>0&&!forceRefresh){console.log(\"\\u26A1 \".concat(cachedCards.length,\" cartas carregadas do cache\"));// Background refresh\nthis.refreshCardsInBackground(deckId);return cachedCards;}// 2. Busca do Firebase se online\nif(navigator.onLine){console.log('üåê Buscando cartas do Firebase:',deckId);const cards=await this.fetchCardsFromFirebase(deckId);// Salva todas no cache\nfor(const card of cards){await unifiedStorage.saveCard(card,{synced:true});}return cards;}return cachedCards;}catch(error){console.error('‚ùå Erro ao buscar cartas:',error);return await unifiedStorage.getDeckCards(deckId);}}/**\r\n   * üîÑ Atualiza cartas em background\r\n   */async refreshCardsInBackground(deckId){if(!navigator.onLine)return;try{const cards=await this.fetchCardsFromFirebase(deckId);for(const card of cards){await unifiedStorage.saveCard(card,{synced:true});}this.notifyListeners(\"cards_\".concat(deckId),cards);}catch(error){console.error('‚ùå Erro ao atualizar cartas em background:',error);}}/**\r\n   * üåê Busca cartas do Firebase\r\n   */async fetchCardsFromFirebase(deckId){const cardsQuery=query(collection(db,'cards'),where('deck_id','==',deckId));const snapshot=await getDocs(cardsQuery);return snapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));}/**\r\n   * üíæ Cria deck (salva local + enfileira sync)\r\n   */async createDeck(deckData,userId){try{// Gera ID tempor√°rio\nconst tempId=\"temp_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9));const deck=_objectSpread(_objectSpread({id:tempId,userId},deckData),{},{created_at:new Date().toISOString(),updated_at:new Date().toISOString()});// Salva no cache local\nawait unifiedStorage.saveDeck(deck,{synced:false,pending:['CREATE']});// Adiciona √† fila de sincroniza√ß√£o\nawait unifiedStorage.addToSyncQueue({type:'CREATE_DECK',entityType:'decks',entityId:tempId,data:deck});console.log('‚úÖ Deck criado localmente:',tempId);// Tenta sincronizar imediatamente\nsyncManager.syncNow();return deck;}catch(error){console.error('‚ùå Erro ao criar deck:',error);throw error;}}/**\r\n   * ‚úèÔ∏è Atualiza deck\r\n   */async updateDeck(deckId,updates){try{// Busca deck atual\nconst currentDeck=await unifiedStorage.getDeck(deckId);if(!currentDeck){throw new Error(\"Deck \".concat(deckId,\" n\\xE3o encontrado\"));}// Atualiza localmente\nconst updatedDeck=_objectSpread(_objectSpread(_objectSpread({},currentDeck),updates),{},{updated_at:new Date().toISOString()});await unifiedStorage.saveDeck(updatedDeck,{synced:false,pending:['UPDATE']});// Enfileira sincroniza√ß√£o\nawait unifiedStorage.addToSyncQueue({type:'UPDATE_DECK',entityType:'decks',entityId:deckId,data:updates});console.log('‚úÖ Deck atualizado localmente:',deckId);// Sincroniza\nsyncManager.syncNow();return updatedDeck;}catch(error){console.error('‚ùå Erro ao atualizar deck:',error);throw error;}}/**\r\n   * üóëÔ∏è Deleta deck\r\n   */async deleteDeck(deckId){try{// Deleta localmente\nawait unifiedStorage.deleteDeck(deckId);// Enfileira sincroniza√ß√£o\nawait unifiedStorage.addToSyncQueue({type:'DELETE_DECK',entityType:'decks',entityId:deckId});console.log('‚úÖ Deck deletado localmente:',deckId);// Sincroniza\nsyncManager.syncNow();}catch(error){console.error('‚ùå Erro ao deletar deck:',error);throw error;}}/**\r\n   * üé¥ Adiciona carta\r\n   */async addCard(deckId,cardData){try{const tempId=\"temp_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9));const card=_objectSpread(_objectSpread({id:tempId,deck_id:deckId},cardData),{},{created_at:new Date().toISOString()});// Salva localmente\nawait unifiedStorage.saveCard(card,{synced:false,pending:['CREATE']});// Enfileira sync\nawait unifiedStorage.addToSyncQueue({type:'CREATE_CARD',entityType:'cards',entityId:tempId,data:card});console.log('‚úÖ Carta adicionada localmente:',tempId);syncManager.syncNow();return card;}catch(error){console.error('‚ùå Erro ao adicionar carta:',error);throw error;}}/**\r\n   * ‚úèÔ∏è Atualiza carta\r\n   */async updateCard(cardId,updates){try{const currentCard=await unifiedStorage.getCard(cardId);if(!currentCard){throw new Error(\"Carta \".concat(cardId,\" n\\xE3o encontrada\"));}const updatedCard=_objectSpread(_objectSpread({},currentCard),updates);await unifiedStorage.saveCard(updatedCard,{synced:false,pending:['UPDATE']});await unifiedStorage.addToSyncQueue({type:'UPDATE_CARD',entityType:'cards',entityId:cardId,data:updates});console.log('‚úÖ Carta atualizada localmente:',cardId);syncManager.syncNow();return updatedCard;}catch(error){console.error('‚ùå Erro ao atualizar carta:',error);throw error;}}/**\r\n   * üóëÔ∏è Deleta carta\r\n   */async deleteCard(cardId){try{await unifiedStorage.deleteCard(cardId);await unifiedStorage.addToSyncQueue({type:'DELETE_CARD',entityType:'cards',entityId:cardId});console.log('‚úÖ Carta deletada localmente:',cardId);syncManager.syncNow();}catch(error){console.error('‚ùå Erro ao deletar carta:',error);throw error;}}/**\r\n   * üîî Registra listener para atualiza√ß√µes\r\n   */subscribe(key,callback){if(!this.listeners.has(key)){this.listeners.set(key,new Set());}this.listeners.get(key).add(callback);// Retorna fun√ß√£o de unsubscribe\nreturn()=>{const callbacks=this.listeners.get(key);if(callbacks){callbacks.delete(callback);}};}/**\r\n   * üì¢ Notifica listeners\r\n   */notifyListeners(key,data){const callbacks=this.listeners.get(key);if(callbacks){callbacks.forEach(callback=>callback(data));}}/**\r\n   * üßπ Limpa cache em mem√≥ria\r\n   */clearCache(){this.cache.clear();console.log('üßπ Cache em mem√≥ria limpo');}}// Singleton\nconst queryManager=new QueryManager();// Exp√µe no window para debug\nif(typeof window!=='undefined'){window.queryManager=queryManager;console.log('üîç QueryManager dispon√≠vel em window.queryManager');}export default queryManager;","map":{"version":3,"names":["unifiedStorage","syncManager","db","collection","query","where","getDocs","doc","getDoc","QueryManager","constructor","cache","Map","listeners","getUserProfile","userId","options","arguments","length","undefined","forceRefresh","cachedProfile","console","log","refreshUserProfileInBackground","navigator","onLine","profile","fetchUserProfileFromFirebase","saveUserProfile","error","notifyListeners","concat","docRef","docSnap","exists","_objectSpread","data","getUserDecks","cachedDecks","refreshDecksInBackground","pullFromFirebase","updatedDecks","getDeck","deckId","cachedDeck","refreshDeckInBackground","deck","fetchDeckFromFirebase","saveDeck","synced","id","getDeckCards","cachedCards","refreshCardsInBackground","cards","fetchCardsFromFirebase","card","saveCard","cardsQuery","snapshot","docs","map","createDeck","deckData","tempId","Date","now","Math","random","toString","substr","created_at","toISOString","updated_at","pending","addToSyncQueue","type","entityType","entityId","syncNow","updateDeck","updates","currentDeck","Error","updatedDeck","deleteDeck","addCard","cardData","deck_id","updateCard","cardId","currentCard","getCard","updatedCard","deleteCard","subscribe","key","callback","has","set","Set","get","add","callbacks","delete","forEach","clearCache","clear","queryManager","window"],"sources":["C:/Users/Lucas Araujo/Desktop/supabase/DeckMaster/src/lib/queryManager.js"],"sourcesContent":["/**\r\n * üîç QUERY MANAGER - Camada de Consultas Offline-First\r\n * =====================================================\r\n * Gerencia consultas priorizando IndexedDB (cache local)\r\n * \r\n * ESTRAT√âGIA:\r\n * 1. Busca SEMPRE do IndexedDB primeiro (instant√¢neo)\r\n * 2. Retorna dados locais imediatamente\r\n * 3. Em background, sincroniza com Firebase\r\n * 4. Notifica componentes quando dados atualizarem\r\n * \r\n * BENEF√çCIOS:\r\n * - Performance instant√¢nea\r\n * - Funciona 100% offline\r\n * - Sincroniza√ß√£o transparente\r\n */\r\n\r\nimport unifiedStorage from './unifiedStorage';\r\nimport syncManager from './syncManager';\r\nimport { db } from '../firebase';\r\nimport { collection, query, where, getDocs, doc, getDoc } from '../firebase';\r\n\r\nclass QueryManager {\r\n  constructor() {\r\n    this.cache = new Map(); // Cache em mem√≥ria para queries recentes\r\n    this.listeners = new Map(); // Listeners para atualiza√ß√µes\r\n  }\r\n\r\n  /**\r\n   * üë§ Busca perfil do usu√°rio\r\n   */\r\n  async getUserProfile(userId, options = {}) {\r\n    const { forceRefresh = false } = options;\r\n\r\n    try {\r\n      // 1. Busca do cache local (instant√¢neo)\r\n      const cachedProfile = await unifiedStorage.getUserProfile(userId);\r\n      \r\n      if (cachedProfile && !forceRefresh) {\r\n        console.log('‚ö° Perfil carregado do cache');\r\n        \r\n        // Em background, atualiza do Firebase\r\n        this.refreshUserProfileInBackground(userId);\r\n        \r\n        return cachedProfile;\r\n      }\r\n\r\n      // 2. Se n√£o tem cache ou forceRefresh, busca do Firebase\r\n      if (navigator.onLine) {\r\n        console.log('üåê Buscando perfil do Firebase...');\r\n        const profile = await this.fetchUserProfileFromFirebase(userId);\r\n        \r\n        if (profile) {\r\n          // Salva no cache\r\n          await unifiedStorage.saveUserProfile(profile);\r\n          return profile;\r\n        }\r\n      }\r\n\r\n      // 3. Fallback para cache mesmo que antigo\r\n      return cachedProfile;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao buscar perfil:', error);\r\n      // Tenta retornar cache em caso de erro\r\n      return await unifiedStorage.getUserProfile(userId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üîÑ Atualiza perfil em background\r\n   */\r\n  async refreshUserProfileInBackground(userId) {\r\n    if (!navigator.onLine) return;\r\n\r\n    try {\r\n      const profile = await this.fetchUserProfileFromFirebase(userId);\r\n      if (profile) {\r\n        await unifiedStorage.saveUserProfile(profile);\r\n        this.notifyListeners(`user_${userId}`, profile);\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar perfil em background:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üåê Busca perfil do Firebase\r\n   */\r\n  async fetchUserProfileFromFirebase(userId) {\r\n    const docRef = doc(db, 'users', userId);\r\n    const docSnap = await getDoc(docRef);\r\n    \r\n    if (docSnap.exists()) {\r\n      return { userId, ...docSnap.data() };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * üÉè Busca todos os decks do usu√°rio\r\n   */\r\n  async getUserDecks(userId, options = {}) {\r\n    const { forceRefresh = false } = options;\r\n\r\n    try {\r\n      // 1. Busca do cache local (instant√¢neo)\r\n      const cachedDecks = await unifiedStorage.getUserDecks(userId);\r\n      \r\n      if (cachedDecks.length > 0 && !forceRefresh) {\r\n        console.log(`‚ö° ${cachedDecks.length} decks carregados do cache`);\r\n        \r\n        // Em background, sincroniza com Firebase\r\n        this.refreshDecksInBackground(userId);\r\n        \r\n        return cachedDecks;\r\n      }\r\n\r\n      // 2. Se n√£o tem cache ou forceRefresh, busca do Firebase\r\n      if (navigator.onLine) {\r\n        console.log('üåê Buscando decks do Firebase...');\r\n        await syncManager.pullFromFirebase(userId);\r\n        \r\n        // Retorna dados atualizados do cache\r\n        return await unifiedStorage.getUserDecks(userId);\r\n      }\r\n\r\n      // 3. Fallback para cache vazio\r\n      return cachedDecks;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao buscar decks:', error);\r\n      return await unifiedStorage.getUserDecks(userId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üîÑ Atualiza decks em background\r\n   */\r\n  async refreshDecksInBackground(userId) {\r\n    if (!navigator.onLine) return;\r\n\r\n    try {\r\n      await syncManager.pullFromFirebase(userId);\r\n      const updatedDecks = await unifiedStorage.getUserDecks(userId);\r\n      this.notifyListeners(`decks_${userId}`, updatedDecks);\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar decks em background:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üé¥ Busca deck espec√≠fico\r\n   */\r\n  async getDeck(deckId, options = {}) {\r\n    const { forceRefresh = false } = options;\r\n\r\n    try {\r\n      // 1. Busca do cache local\r\n      const cachedDeck = await unifiedStorage.getDeck(deckId);\r\n      \r\n      if (cachedDeck && !forceRefresh) {\r\n        console.log('‚ö° Deck carregado do cache:', deckId);\r\n        \r\n        // Background refresh\r\n        this.refreshDeckInBackground(deckId);\r\n        \r\n        return cachedDeck;\r\n      }\r\n\r\n      // 2. Busca do Firebase se online\r\n      if (navigator.onLine) {\r\n        console.log('üåê Buscando deck do Firebase:', deckId);\r\n        const deck = await this.fetchDeckFromFirebase(deckId);\r\n        \r\n        if (deck) {\r\n          await unifiedStorage.saveDeck(deck, { synced: true });\r\n          return deck;\r\n        }\r\n      }\r\n\r\n      return cachedDeck;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao buscar deck:', error);\r\n      return await unifiedStorage.getDeck(deckId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üîÑ Atualiza deck em background\r\n   */\r\n  async refreshDeckInBackground(deckId) {\r\n    if (!navigator.onLine) return;\r\n\r\n    try {\r\n      const deck = await this.fetchDeckFromFirebase(deckId);\r\n      if (deck) {\r\n        await unifiedStorage.saveDeck(deck, { synced: true });\r\n        this.notifyListeners(`deck_${deckId}`, deck);\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar deck em background:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üåê Busca deck do Firebase\r\n   */\r\n  async fetchDeckFromFirebase(deckId) {\r\n    const docRef = doc(db, 'decks', deckId);\r\n    const docSnap = await getDoc(docRef);\r\n    \r\n    if (docSnap.exists()) {\r\n      return { id: deckId, ...docSnap.data() };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * üé¥ Busca cartas de um deck\r\n   */\r\n  async getDeckCards(deckId, options = {}) {\r\n    const { forceRefresh = false } = options;\r\n\r\n    try {\r\n      // 1. Busca do cache local\r\n      const cachedCards = await unifiedStorage.getDeckCards(deckId);\r\n      \r\n      if (cachedCards.length > 0 && !forceRefresh) {\r\n        console.log(`‚ö° ${cachedCards.length} cartas carregadas do cache`);\r\n        \r\n        // Background refresh\r\n        this.refreshCardsInBackground(deckId);\r\n        \r\n        return cachedCards;\r\n      }\r\n\r\n      // 2. Busca do Firebase se online\r\n      if (navigator.onLine) {\r\n        console.log('üåê Buscando cartas do Firebase:', deckId);\r\n        const cards = await this.fetchCardsFromFirebase(deckId);\r\n        \r\n        // Salva todas no cache\r\n        for (const card of cards) {\r\n          await unifiedStorage.saveCard(card, { synced: true });\r\n        }\r\n        \r\n        return cards;\r\n      }\r\n\r\n      return cachedCards;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao buscar cartas:', error);\r\n      return await unifiedStorage.getDeckCards(deckId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üîÑ Atualiza cartas em background\r\n   */\r\n  async refreshCardsInBackground(deckId) {\r\n    if (!navigator.onLine) return;\r\n\r\n    try {\r\n      const cards = await this.fetchCardsFromFirebase(deckId);\r\n      \r\n      for (const card of cards) {\r\n        await unifiedStorage.saveCard(card, { synced: true });\r\n      }\r\n      \r\n      this.notifyListeners(`cards_${deckId}`, cards);\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar cartas em background:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üåê Busca cartas do Firebase\r\n   */\r\n  async fetchCardsFromFirebase(deckId) {\r\n    const cardsQuery = query(\r\n      collection(db, 'cards'),\r\n      where('deck_id', '==', deckId)\r\n    );\r\n    const snapshot = await getDocs(cardsQuery);\r\n    \r\n    return snapshot.docs.map(doc => ({\r\n      id: doc.id,\r\n      ...doc.data()\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * üíæ Cria deck (salva local + enfileira sync)\r\n   */\r\n  async createDeck(deckData, userId) {\r\n    try {\r\n      // Gera ID tempor√°rio\r\n      const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      \r\n      const deck = {\r\n        id: tempId,\r\n        userId,\r\n        ...deckData,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      // Salva no cache local\r\n      await unifiedStorage.saveDeck(deck, { \r\n        synced: false,\r\n        pending: ['CREATE']\r\n      });\r\n\r\n      // Adiciona √† fila de sincroniza√ß√£o\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'CREATE_DECK',\r\n        entityType: 'decks',\r\n        entityId: tempId,\r\n        data: deck\r\n      });\r\n\r\n      console.log('‚úÖ Deck criado localmente:', tempId);\r\n\r\n      // Tenta sincronizar imediatamente\r\n      syncManager.syncNow();\r\n\r\n      return deck;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao criar deck:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ‚úèÔ∏è Atualiza deck\r\n   */\r\n  async updateDeck(deckId, updates) {\r\n    try {\r\n      // Busca deck atual\r\n      const currentDeck = await unifiedStorage.getDeck(deckId);\r\n      \r\n      if (!currentDeck) {\r\n        throw new Error(`Deck ${deckId} n√£o encontrado`);\r\n      }\r\n\r\n      // Atualiza localmente\r\n      const updatedDeck = {\r\n        ...currentDeck,\r\n        ...updates,\r\n        updated_at: new Date().toISOString()\r\n      };\r\n\r\n      await unifiedStorage.saveDeck(updatedDeck, {\r\n        synced: false,\r\n        pending: ['UPDATE']\r\n      });\r\n\r\n      // Enfileira sincroniza√ß√£o\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'UPDATE_DECK',\r\n        entityType: 'decks',\r\n        entityId: deckId,\r\n        data: updates\r\n      });\r\n\r\n      console.log('‚úÖ Deck atualizado localmente:', deckId);\r\n\r\n      // Sincroniza\r\n      syncManager.syncNow();\r\n\r\n      return updatedDeck;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar deck:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üóëÔ∏è Deleta deck\r\n   */\r\n  async deleteDeck(deckId) {\r\n    try {\r\n      // Deleta localmente\r\n      await unifiedStorage.deleteDeck(deckId);\r\n\r\n      // Enfileira sincroniza√ß√£o\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'DELETE_DECK',\r\n        entityType: 'decks',\r\n        entityId: deckId\r\n      });\r\n\r\n      console.log('‚úÖ Deck deletado localmente:', deckId);\r\n\r\n      // Sincroniza\r\n      syncManager.syncNow();\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao deletar deck:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üé¥ Adiciona carta\r\n   */\r\n  async addCard(deckId, cardData) {\r\n    try {\r\n      const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      \r\n      const card = {\r\n        id: tempId,\r\n        deck_id: deckId,\r\n        ...cardData,\r\n        created_at: new Date().toISOString()\r\n      };\r\n\r\n      // Salva localmente\r\n      await unifiedStorage.saveCard(card, {\r\n        synced: false,\r\n        pending: ['CREATE']\r\n      });\r\n\r\n      // Enfileira sync\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'CREATE_CARD',\r\n        entityType: 'cards',\r\n        entityId: tempId,\r\n        data: card\r\n      });\r\n\r\n      console.log('‚úÖ Carta adicionada localmente:', tempId);\r\n\r\n      syncManager.syncNow();\r\n\r\n      return card;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao adicionar carta:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ‚úèÔ∏è Atualiza carta\r\n   */\r\n  async updateCard(cardId, updates) {\r\n    try {\r\n      const currentCard = await unifiedStorage.getCard(cardId);\r\n      \r\n      if (!currentCard) {\r\n        throw new Error(`Carta ${cardId} n√£o encontrada`);\r\n      }\r\n\r\n      const updatedCard = {\r\n        ...currentCard,\r\n        ...updates\r\n      };\r\n\r\n      await unifiedStorage.saveCard(updatedCard, {\r\n        synced: false,\r\n        pending: ['UPDATE']\r\n      });\r\n\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'UPDATE_CARD',\r\n        entityType: 'cards',\r\n        entityId: cardId,\r\n        data: updates\r\n      });\r\n\r\n      console.log('‚úÖ Carta atualizada localmente:', cardId);\r\n\r\n      syncManager.syncNow();\r\n\r\n      return updatedCard;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao atualizar carta:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üóëÔ∏è Deleta carta\r\n   */\r\n  async deleteCard(cardId) {\r\n    try {\r\n      await unifiedStorage.deleteCard(cardId);\r\n\r\n      await unifiedStorage.addToSyncQueue({\r\n        type: 'DELETE_CARD',\r\n        entityType: 'cards',\r\n        entityId: cardId\r\n      });\r\n\r\n      console.log('‚úÖ Carta deletada localmente:', cardId);\r\n\r\n      syncManager.syncNow();\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Erro ao deletar carta:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üîî Registra listener para atualiza√ß√µes\r\n   */\r\n  subscribe(key, callback) {\r\n    if (!this.listeners.has(key)) {\r\n      this.listeners.set(key, new Set());\r\n    }\r\n    this.listeners.get(key).add(callback);\r\n\r\n    // Retorna fun√ß√£o de unsubscribe\r\n    return () => {\r\n      const callbacks = this.listeners.get(key);\r\n      if (callbacks) {\r\n        callbacks.delete(callback);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * üì¢ Notifica listeners\r\n   */\r\n  notifyListeners(key, data) {\r\n    const callbacks = this.listeners.get(key);\r\n    if (callbacks) {\r\n      callbacks.forEach(callback => callback(data));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * üßπ Limpa cache em mem√≥ria\r\n   */\r\n  clearCache() {\r\n    this.cache.clear();\r\n    console.log('üßπ Cache em mem√≥ria limpo');\r\n  }\r\n}\r\n\r\n// Singleton\r\nconst queryManager = new QueryManager();\r\n\r\n// Exp√µe no window para debug\r\nif (typeof window !== 'undefined') {\r\n  window.queryManager = queryManager;\r\n  console.log('üîç QueryManager dispon√≠vel em window.queryManager');\r\n}\r\n\r\nexport default queryManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}