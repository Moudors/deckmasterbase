{"ast":null,"code":"// src/utils/userUtils.js\nimport{supabase}from'../supabase';import{userOperations}from'../lib/supabaseOperations';import{v4 as uuidv4}from\"uuid\";/**\r\n * Garante que o usuário tenha um documento no Supabase\r\n * com UUID único e campos básicos.\r\n */export async function ensureUserProfile(user){if(!(user!==null&&user!==void 0&&user.id))return;const existingUser=await userOperations.getUser(user.id);if(!existingUser){var _user$user_metadata;const userData={id:user.id,uuid:uuidv4(),// UUID único e imutável\nemail:user.email,display_name:((_user$user_metadata=user.user_metadata)===null||_user$user_metadata===void 0?void 0:_user$user_metadata.full_name)||\"\",username:null,bio:\"\",friends:[],created_at:new Date().toISOString()};const{data,error}=await supabase.from('users').insert(userData).select().single();if(error)throw error;return data;}return existingUser;}/**\r\n * Atualiza o username garantindo unicidade global.\r\n * - Cria um doc em `usernames/{username}` apontando para o uid.\r\n * - Atualiza o campo `username` no doc do usuário.\r\n * - Remove o username antigo, se existir.\r\n */export async function updateUsername(uid,newUsername){if(!uid||!newUsername)throw new Error(\"Dados inválidos\");const normalized=newUsername.toLowerCase();// Verificar se username já existe\nconst existingUsername=await userOperations.getUserByUsername(normalized);if(existingUsername){throw new Error(\"Este username já está em uso\");}// Buscar usuário atual\nconst currentUser=await userOperations.getUser(uid);if(!currentUser)throw new Error(\"Usuário não encontrado\");const oldUsername=currentUser.username;// Atualizar username do usuário\nawait userOperations.updateUser(uid,{username:normalized});// Criar entrada na tabela usernames\nconst{error:usernameError}=await supabase.from('usernames').insert({id:normalized,uid:uid,created_at:new Date().toISOString()});if(usernameError){console.error('Erro ao criar entrada de username:',usernameError);// Reverter mudança no usuário se falhar\nawait userOperations.updateUser(uid,{username:oldUsername});throw usernameError;}// Remover username antigo se existir\nif(oldUsername){await supabase.from('usernames').delete().eq('id',oldUsername);}}","map":{"version":3,"names":["supabase","userOperations","v4","uuidv4","ensureUserProfile","user","id","existingUser","getUser","_user$user_metadata","userData","uuid","email","display_name","user_metadata","full_name","username","bio","friends","created_at","Date","toISOString","data","error","from","insert","select","single","updateUsername","uid","newUsername","Error","normalized","toLowerCase","existingUsername","getUserByUsername","currentUser","oldUsername","updateUser","usernameError","console","delete","eq"],"sources":["C:/Users/Lucas Araujo/Desktop/supabase/DeckMaster/src/utils/userUtils.js"],"sourcesContent":["// src/utils/userUtils.js\r\nimport { supabase } from '../supabase';\r\nimport { userOperations } from '../lib/supabaseOperations';\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\n/**\r\n * Garante que o usuário tenha um documento no Supabase\r\n * com UUID único e campos básicos.\r\n */\r\nexport async function ensureUserProfile(user) {\r\n  if (!user?.id) return;\r\n\r\n  const existingUser = await userOperations.getUser(user.id);\r\n\r\n  if (!existingUser) {\r\n    const userData = {\r\n      id: user.id,\r\n      uuid: uuidv4(), // UUID único e imutável\r\n      email: user.email,\r\n      display_name: user.user_metadata?.full_name || \"\",\r\n      username: null,\r\n      bio: \"\",\r\n      friends: [],\r\n      created_at: new Date().toISOString(),\r\n    };\r\n\r\n    const { data, error } = await supabase\r\n      .from('users')\r\n      .insert(userData)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  }\r\n\r\n  return existingUser;\r\n}\r\n\r\n/**\r\n * Atualiza o username garantindo unicidade global.\r\n * - Cria um doc em `usernames/{username}` apontando para o uid.\r\n * - Atualiza o campo `username` no doc do usuário.\r\n * - Remove o username antigo, se existir.\r\n */\r\nexport async function updateUsername(uid, newUsername) {\r\n  if (!uid || !newUsername) throw new Error(\"Dados inválidos\");\r\n\r\n  const normalized = newUsername.toLowerCase();\r\n  \r\n  // Verificar se username já existe\r\n  const existingUsername = await userOperations.getUserByUsername(normalized);\r\n  if (existingUsername) {\r\n    throw new Error(\"Este username já está em uso\");\r\n  }\r\n\r\n  // Buscar usuário atual\r\n  const currentUser = await userOperations.getUser(uid);\r\n  if (!currentUser) throw new Error(\"Usuário não encontrado\");\r\n\r\n  const oldUsername = currentUser.username;\r\n\r\n  // Atualizar username do usuário\r\n  await userOperations.updateUser(uid, { username: normalized });\r\n\r\n  // Criar entrada na tabela usernames\r\n  const { error: usernameError } = await supabase\r\n    .from('usernames')\r\n    .insert({\r\n      id: normalized,\r\n      uid: uid,\r\n      created_at: new Date().toISOString()\r\n    });\r\n\r\n  if (usernameError) {\r\n    console.error('Erro ao criar entrada de username:', usernameError);\r\n    // Reverter mudança no usuário se falhar\r\n    await userOperations.updateUser(uid, { username: oldUsername });\r\n    throw usernameError;\r\n  }\r\n\r\n  // Remover username antigo se existir\r\n  if (oldUsername) {\r\n    await supabase\r\n      .from('usernames')\r\n      .delete()\r\n      .eq('id', oldUsername);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}