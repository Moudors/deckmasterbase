{"ast":null,"code":"/**\r\n * 🎣 HOOK: useImageCache\r\n * ======================\r\n * Hook React para carregar imagens do cache local (IndexedDB)\r\n * \r\n * USO:\r\n * ```jsx\r\n * const cachedUrl = useImageCache(card.image_url);\r\n * \r\n * <img src={cachedUrl} alt={card.name} />\r\n * ```\r\n * \r\n * FUNCIONAMENTO:\r\n * 1. Retorna '' inicialmente (placeholder)\r\n * 2. Busca no cache IndexedDB\r\n * 3. Se não estiver em cache, baixa e salva\r\n * 4. Retorna Blob URL local (blob://...)\r\n * 5. Se falhar, retorna URL original\r\n */import{useState,useEffect}from'react';import{getImage}from'../lib/imageCache';/**\r\n * @param {string} imageUrl - URL da imagem (Scryfall, Firebase, etc.)\r\n * @param {boolean} enabled - Se false, não carrega imagem (útil para lazy load)\r\n * @returns {string} - Blob URL local ou URL original\r\n */export function useImageCache(imageUrl){let enabled=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const[cachedUrl,setCachedUrl]=useState('');useEffect(()=>{if(!imageUrl||!enabled){setCachedUrl('');return;}let isMounted=true;// Limpa URL anterior se existir\nif(cachedUrl&&cachedUrl.startsWith('blob:')){URL.revokeObjectURL(cachedUrl);}// Reset para mostrar loading/vazio enquanto carrega nova imagem\nsetCachedUrl('');async function loadImage(){try{const url=await getImage(imageUrl);if(isMounted){setCachedUrl(url);}}catch(error){console.error('❌ Erro ao carregar imagem:',error);// Fallback para URL original\nif(isMounted){setCachedUrl(imageUrl);}}}loadImage();// Cleanup: revoga Blob URL quando componente desmonta\nreturn()=>{isMounted=false;// Se for Blob URL local, revoga para liberar memória\nif(cachedUrl&&cachedUrl.startsWith('blob:')){URL.revokeObjectURL(cachedUrl);}};},[imageUrl,enabled]);// Remove cachedUrl das dependencies para evitar loop\nreturn cachedUrl;}export default useImageCache;","map":{"version":3,"names":["useState","useEffect","getImage","useImageCache","imageUrl","enabled","arguments","length","undefined","cachedUrl","setCachedUrl","isMounted","startsWith","URL","revokeObjectURL","loadImage","url","error","console"],"sources":["C:/Users/Lucas Araujo/Desktop/supabase/DeckMaster/src/hooks/useImageCache.js"],"sourcesContent":["/**\r\n * 🎣 HOOK: useImageCache\r\n * ======================\r\n * Hook React para carregar imagens do cache local (IndexedDB)\r\n * \r\n * USO:\r\n * ```jsx\r\n * const cachedUrl = useImageCache(card.image_url);\r\n * \r\n * <img src={cachedUrl} alt={card.name} />\r\n * ```\r\n * \r\n * FUNCIONAMENTO:\r\n * 1. Retorna '' inicialmente (placeholder)\r\n * 2. Busca no cache IndexedDB\r\n * 3. Se não estiver em cache, baixa e salva\r\n * 4. Retorna Blob URL local (blob://...)\r\n * 5. Se falhar, retorna URL original\r\n */\r\n\r\nimport { useState, useEffect } from 'react';\r\nimport { getImage } from '../lib/imageCache';\r\n\r\n/**\r\n * @param {string} imageUrl - URL da imagem (Scryfall, Firebase, etc.)\r\n * @param {boolean} enabled - Se false, não carrega imagem (útil para lazy load)\r\n * @returns {string} - Blob URL local ou URL original\r\n */\r\nexport function useImageCache(imageUrl, enabled = true) {\r\n  const [cachedUrl, setCachedUrl] = useState('');\r\n\r\n  useEffect(() => {\r\n    if (!imageUrl || !enabled) {\r\n      setCachedUrl('');\r\n      return;\r\n    }\r\n\r\n    let isMounted = true;\r\n    \r\n    // Limpa URL anterior se existir\r\n    if (cachedUrl && cachedUrl.startsWith('blob:')) {\r\n      URL.revokeObjectURL(cachedUrl);\r\n    }\r\n    \r\n    // Reset para mostrar loading/vazio enquanto carrega nova imagem\r\n    setCachedUrl('');\r\n\r\n    async function loadImage() {\r\n      try {\r\n        const url = await getImage(imageUrl);\r\n        \r\n        if (isMounted) {\r\n          setCachedUrl(url);\r\n        }\r\n      } catch (error) {\r\n        console.error('❌ Erro ao carregar imagem:', error);\r\n        \r\n        // Fallback para URL original\r\n        if (isMounted) {\r\n          setCachedUrl(imageUrl);\r\n        }\r\n      }\r\n    }\r\n\r\n    loadImage();\r\n\r\n    // Cleanup: revoga Blob URL quando componente desmonta\r\n    return () => {\r\n      isMounted = false;\r\n      \r\n      // Se for Blob URL local, revoga para liberar memória\r\n      if (cachedUrl && cachedUrl.startsWith('blob:')) {\r\n        URL.revokeObjectURL(cachedUrl);\r\n      }\r\n    };\r\n  }, [imageUrl, enabled]); // Remove cachedUrl das dependencies para evitar loop\r\n\r\n  return cachedUrl;\r\n}\r\n\r\nexport default useImageCache;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,OAASA,QAAQ,CAAEC,SAAS,KAAQ,OAAO,CAC3C,OAASC,QAAQ,KAAQ,mBAAmB,CAE5C;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAC,aAAaA,CAACC,QAAQ,CAAkB,IAAhB,CAAAC,OAAO,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,IAAI,CACpD,KAAM,CAACG,SAAS,CAAEC,YAAY,CAAC,CAAGV,QAAQ,CAAC,EAAE,CAAC,CAE9CC,SAAS,CAAC,IAAM,CACd,GAAI,CAACG,QAAQ,EAAI,CAACC,OAAO,CAAE,CACzBK,YAAY,CAAC,EAAE,CAAC,CAChB,OACF,CAEA,GAAI,CAAAC,SAAS,CAAG,IAAI,CAEpB;AACA,GAAIF,SAAS,EAAIA,SAAS,CAACG,UAAU,CAAC,OAAO,CAAC,CAAE,CAC9CC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC,CAChC,CAEA;AACAC,YAAY,CAAC,EAAE,CAAC,CAEhB,cAAe,CAAAK,SAASA,CAAA,CAAG,CACzB,GAAI,CACF,KAAM,CAAAC,GAAG,CAAG,KAAM,CAAAd,QAAQ,CAACE,QAAQ,CAAC,CAEpC,GAAIO,SAAS,CAAE,CACbD,YAAY,CAACM,GAAG,CAAC,CACnB,CACF,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAElD;AACA,GAAIN,SAAS,CAAE,CACbD,YAAY,CAACN,QAAQ,CAAC,CACxB,CACF,CACF,CAEAW,SAAS,CAAC,CAAC,CAEX;AACA,MAAO,IAAM,CACXJ,SAAS,CAAG,KAAK,CAEjB;AACA,GAAIF,SAAS,EAAIA,SAAS,CAACG,UAAU,CAAC,OAAO,CAAC,CAAE,CAC9CC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC,CAChC,CACF,CAAC,CACH,CAAC,CAAE,CAACL,QAAQ,CAAEC,OAAO,CAAC,CAAC,CAAE;AAEzB,MAAO,CAAAI,SAAS,CAClB,CAEA,cAAe,CAAAN,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}